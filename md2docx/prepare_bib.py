from json import dump
from re import split, findall

import latexcodec  # it's necessary to import it here


TYPES = {'article': "article-journal",
         'book': 'book',
         'incollection': 'chapter',
         'inproceedings': 'paper-conference',
         'phdthesis': 'thesis',
         }

FIELDS = {'author': 'author',
          'title': 'title',
          'volume': 'volume',
          'number': 'issue',
          'pages': 'page',
          'year': 'issued',
          'journal': 'container-title',
          'booktitle': 'container-title',  # chapter
          'editor': 'editor',
          'publisher': 'publisher',
          'address': 'publisher-place',
          }

# simplify when it has both latex and utf8 in the same name
UTF8_SYMBOLS = {
    'ð': 'd',
    'ƒ': 'f',
    'Þ': 'th',
    '€': 'EUR',
    '«': '<<',
    '»': '>>',
    }

LATEX_SYMBOLS = {'$\\alpha$': 'α',
                 '$\\beta$': 'β',
                 '$\\gamma$': 'γ',
                 '$\\delta$': 'δ',
                 '$\\Sigma$': 'Σ',
                 '$\\epsilon$': 'ϵ',
                 '$\\eta$': 'η',
                 '$\\mu$': 'μ',
                 '$\\sim$': '~',
                 '$\\theta$': 'θ',
                 '$\\zeta$': 'ζ',
                 }


def fix_biblio(biblio_orig):
    """fix bibliography by keeping only useful fields.

    Parameters
    ----------
    orig_bib_file : path to .bib file
        directory with optional information

    Returns
    -------
    path to file
        bib file with a simpler structure.
    """
    biblio = biblio_orig.with_suffix('.json')

    if not biblio.exists() or biblio_orig.stat().st_mtime > biblio.stat().st_mtime:
        prepare_bib(biblio_orig, biblio)

    return biblio


def prepare_bib(old_bib, new_bib):
    with old_bib.open(errors='ignore') as f:
        bib_orig = f.read()

    for latex_name, symbol in LATEX_SYMBOLS.items():
        bib_orig = bib_orig.replace(latex_name, symbol)

    keys = findall('@([a-z]+){([\w]*),', bib_orig)
    entries = split('@[a-z]+{[\w]*,', bib_orig)[1:]  # the first one is the autogenerated script by Mendeley

    assert len(keys) == len(entries)

    j_entries = {}
    for key, entry in zip(keys, entries):
        j_entries[key[1]] = fix_entry(key, entry)

    with new_bib.open('w') as f:
        # dump(j_entries, f, separators=(',', ':'))
        dump(j_entries, f, indent=2)


def fix_entry(key, entry):
    j_entry = {'id': key[1],
               'type': TYPES[key[0]]}

    for field, value in findall('\n([a-z]*) = {(.*)}', entry):
        if field in ('author', 'editor'):
            author_keys = []
            for one_author in value.split(' and '):
                if '{' in one_author:
                    for utf8_symbol, ascii_symbol in UTF8_SYMBOLS.items():
                        one_author = one_author.replace(utf8_symbol, ascii_symbol)  # simplify when it has both latex and utf8 in the same name
                    one_author = one_author.encode('latex').decode("latex")
                    one_author = one_author.replace('{', '').replace('}', '')

                author_name = one_author.split(', ')
                author_key = {'family': fix_case(author_name[0])}
                if len(author_name) > 1:
                    author_key['given'] = fix_case(author_name[1])
                author_keys.append(author_key)

            value = author_keys

        if field == 'pages':
            value = value.replace('--', '-')

        if field == 'year':
            value = {'raw': value}

        if field == 'title':
            value = value.strip('{}')

        if field in FIELDS:
            j_entry[FIELDS[field]] = value

    return j_entry


def fix_case(name):
    """Old records in Pubmed tend to have author names with all upper cases,
    which is clearly incorrect. So here we convert those names to title case.
    I don't expect weird side effects, but there might be exceptions.

    The case of the key for citations remains the same (probably all upper case)
    """
    names = [n.strip() for n in name.split(' ')]

    names = [n.capitalize() if n.isupper() else n for n in names]
    return ' '.join(names)
